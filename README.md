<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      body{
        color: white
      }
      h1 {
        color: white;
        font-size: 36px;
      }
      h1:hover{
        color: red;
      }
      h2 {
        color: white;
        font-size: 24px;
      }
      h2:hover{
        color: red;
      }
      h3 {
        color: white;
        font-size: 20px
      }
      h3:hover {
        color: red
      }
      h4{
        color: white;
        font-size: 16px
      }
      h4:hover{
        color: red
      }
      li{
        color: white;
        font-size: 18px;
        font-weight: bold
      }
      li:hover{
        color: red;
      }
      b{
        background-color: #373737;
        border-radius: 5px;
        padding: 4px
      }
      b:hover{
        color: red
      }
      i{
        color: green
      }
      .text{
        font-size: 14px;
        font-weight: normal
      }
      .text:hover{
        color: white
      }
    </style>
  </head>
  <body>
    <h1>RoadMap</h1>
    <p>В данном руководстве расписаны основные технологии, которые используются в современном мире разработки.</p>
    <div class=container>
      <h1>Оглавление</h1>
      <ul>  
        <li>Docker</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
              <ul>
                <li>Недостатки</li>
                <li>Преимущества</li>
              </ul>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>Dockerfile</li>
              <ul>
                <li>Краткие сведения</li>
                <li>Основные команды</li>
                <li>Пример файла</li>
              </ul>
            <li>docker-compose.yml</li>
              <ul>
                <li>Краткие сведения</li>
                <li>Основные команды</li>
                <li>Основные поля</li>
                <li>Основные технологии для развертывания</li>
                  <ul>
                    <li>Nats</li>
                    <li>PostgreSQL</li>
                    <li>PGAdmin</li>
                    <li>Selery</li>
                    <li>Redis</li>
                    <li>RabbitMQ</li>
                    <li>ElasticSearch</li>
                    <li>Деплой приложения</li>
                  </ul>
              </ul>
            <li>Список источников</li>
          </ul>
        <li>PostgreSQL</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>SQL-запросы</li>
              <ul>
                <li>TBC</li>
              </ul>
            <li>Взаимодействие с Python</li>
              <ul>
                <li>SQLAlchemy</li>
                  <ul>
                    <li>ORM</li>
                    <li>Mapped, mapped_column()</li>
                    <li>Declarative Base, Metadata</li>
                    <li>Из каких библиотек всё брать</li>
                  </ul>
                <li>psycopg2/asyncpg</li>
                <li>alembic</li>
                  <ul>
                    <li>revision</li>
                  </ul>
              </ul>
          </ul>
        <li>Nats</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>Взаимодействие с Python</li>
          </ul>
        <li>Selery</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>Взаимодействие с Python</li>
          </ul>
        <li>Redis</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>Взаимодействие с Python</li>
          </ul>
        <li>ElasticSearch</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>Взаимодействие с Python</li>
          </ul>
        <li>Git</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
          </ul>
        <li>Linux</li>
          <ul>
            <li></li>
          </ul>
        <li>FastAPI</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Аналоги</li>
            <li>Основные команды</li>
            <li>Взаимодействие с Python</li>
          </ul>
        <li>REST API</li>
          <ul>
            <li></li>
          </ul>
        <li>Python</li>
          <ul>
            <li>Краткие сведения</li>
            <li>Преимущества и недостатки</li>
            <li>Виртуальное окружение</li>
              <li>Краткие сведения</li>
              <li>Основные команды</li>
            <li>ООП</li>
              <ul>
                <li>Определение</li>
                <li>Назначение</li>
                <li>Основные концепции</li>
                  <ul>
                    <li>Наследование</li>
                    <li>Полиморфизм</li>
                    <li>Инкапсуляция</li>
                  </ul>
                <li>Дандер методы</li>
              </ul>    
          </ul>
      </ul>
    </div>
    <div id="docker" class="container">
      <h1>Docker</h1>
      <div class="content">
        <h2>Краткие сведения</h2>
        <div class="text">
          <p><b>Docker</b> - программное обеспечение для автоматизации развёртывания и управления приложениями в среде виртуализации на уровне операционной системы; позволяет «упаковать» приложение со всем его окружением и зависимостями в контейнер, а также предоставляет среду по управлению контейнерами.</p>
          <p><i>Простым языком</i>:<br><b>Docker</b> - это инструмент, который позволяет разработчикам, системными администраторам и другим специалистам деплоить их приложения в песочнице (которые называются контейнерами), для запуска на целевой операционной системе, например, <b>Linux</b>.</p>
          <p>В целом, <b>Docker</b> является мощным инструментом для контейнеризации приложений, но его использование требует понимания его преимуществ и недостатков и правильного подхода к развертыванию и управлению контейнерами.</p>
        </div>
        <h2>Преимущества и недостатки</h2>
        <div class="text">
          <h3>Недостатки</h3>
          <p><ul>
            <li class="text"><p><b>Производительность</b></p> Docker вносит некоторые накладные расходы на производительность, поскольку включает в себя дополнительный слой виртуализации. В некоторых случаях, особенно если есть необходимость в высоком уровне изоляции, производительность контейнера может быть несколько ниже, чем на хостовой системе.</li>
            <br>
            <li class="text"><p><b>Расход ресурсов</b></p> Контейнеры Docker используют ресурсы, такие как память и процессорное время. Если на сервере множество контейнеров, это может привести к увеличенному расходу процессора, памяти и дискового пространства.</li>
            <br>
            <li class="text"><p><b>Комплексность</b></p>Docker предлагает широкий набор функций и инструментов, что может вызвать некоторую сложность для новичков. Необходимо изучить основные концепции Docker и настроить его правильно, чтобы достичь максимальной эффективности.</li>
            <br>
            <li class="text"><p><b>Безопасность</b></p>Docker изолирует контейнеры, но все же существует некоторый риск, что недостаточно обеспеченные контейнеры могут быть скомпрометированы. Необходимо принимать меры для обеспечения безопасности контейнеров, такие как ограничение привилегий и настройка прав доступа.</li>
          </ul></p>
          <h3>Преимущества</h3>
          <p><ul>
            <li class="text"><p><b>Изолированная среда</b></p>Docker контейнеры предоставляют изолированную среду для выполнения приложений. Каждый контейнер содержит все необходимые зависимости, файловую систему и ресурсы, изолируя его от других контейнеров и хостовой операционной системы. Это позволяет избежать конфликтов между зависимостями и упрощает развертывание.</li>
            <br>
            <li class="text"><p><b>Портативность</b></p>Docker обеспечивает портативность приложений. Поскольку контейнеры содержат все зависимости и настройки, приложение может быть запущено на любом хосте, который поддерживает Docker. Это облегчает развертывание приложений в различных средах, таких как разработка, тестирование и производство.</li>
            <br>
            <li class="text"><p><b>Масштабируемост</b></p>Docker позволяет легко масштабировать приложения. Вы можете создавать несколько экземпляров контейнера для обработки больших нагрузок или использовать оркестраторы контейнеров, такие как Docker Swarm или Kubernetes, для автоматического масштабирования и управления контейнерами.</li>
            <br>
            <li class="text"><p><b>Быстрое развертывание и воспроизводимость</b></p>Docker позволяет быстро развернуть и воспроизводить приложения, поскольку контейнеры содержат все необходимое для их работы. Вы можете создать образ контейнера со всеми зависимостями и настройками приложения и легко развернуть его на других системах.</li>
          </ul></p>
        </div>
        <h2>Аналоги</h2>
        <div class="text">
          <p>В мире контейнеризации существует несколько популярных аналогов Docker. Вот некоторые из них и их краткое описание</p>
          <ol>
            <li class="text"><p><b>Kubernetes</b></p><b>Kubernetes (K8s)</b> - это оркестратор контейнеров с открытым исходным кодом, который позволяет автоматизировать развертывание, масштабирование и управление контейнеризированными приложениями. Kubernetes более широко используется в сравнении с другими альтернативами и предоставляет богатый набор функций для развертывания и управления контейнерами, таких как масштабирование, обнаружение сервисов, управление сетью и обновление без простоев. Однако, <b>Kubernetes</b> сам по себе не является альтернативой для <b>Docker</b>, а скорее может использоваться вместе с <b>Docker</b> для эффективного управления контейнерами.</li>
            <br>
            <li class="text"><p><b>rkt (Rocker)</b></p><b>rkt</b> (также известный как <b>Rocker</b>) - это другое альтернативное решение для <b>Docker</b>. Он был разработан командой <b>CoreOS</b> и обеспечивает безопасность, простоту использования и прозрачность. Ключевое отличие rkt заключается в его архитектуре, где каждый контейнер работает в своей изолированной окружении, а взаимодействие между контейнерами осуществляется через передачу файлов (<i>file descriptor passing</i>) и другие декларативные протоколы.</li>
            <br>
            <li class="text"><p><b>LXD</b></p><b>LXD</b> (<i>Linux Container Daemon</i>) также предоставляет альтернативу <b>Docker</b>. Он является системой управления контейнерами, которая предназначена для хостов <b>Linux</b>. <b>LXD</b> позволяет запускать системные контейнеры, которые более похожи на виртуальные машины, чем на обычные контейнеры <b>Docker</b>. Он также обеспечивает изоляцию и управление ресурсами, но с использованием более тяжеловесных контейнеров.</li>
            <br>
            <li class="text"><p><b>Podman</b></p><b>Подман</b> (<i>Pod Manager</i>) представляет собой средство для управления контейнерами, которое предлагает альтернативу для Docker. Он обеспечивает совместимость с Docker API, что позволяет запускать и управлять контейнерами так же, как и с помощью Docker. Однако, в отличие от Docker, Podman не требует привилегированного доступа и не использует демона, вместо этого он запускает контейнеры в изолированных процессах.</li>
            <br>
            <li class="text"><p><b>OpenShift</b></p><b>OpenShift</b> является платформой контейнеризации и разработки приложений, основанной на <b>Kubernetes</b>. В отличие от простой контейнеризации, <b>OpenShift</b> обеспечивает дополнительные функции, такие как автоматизированное масштабирование, мониторинг, управление доступом и деплой приложений в облаке.</li>
          </ol>
        </div>
        <h2>Основные команды</h2>
        <div class="text">
          <ol>
            <li class="text"><p><b>docker run</b> - запускает контейнер. Если изображение, из которого создается контейнер, не найдено локально, Docker попытается загрузить его из репозитория.</p>Пример: docker run -d -p 8080:80 nginx (Запускает контейнер nginx в фоновом режиме, привязывая порт 8080 хоста к порту 80 контейнера.)</li>
            <li class="text"><p><b>docker exec</b> - выполняет команду в работающем контейнере.</p>Пример: docker exec my_container ls (Выполняет команду ls в контейнере с именем my_container.)</li>
            <li class="text"><p><b>docker ps</b> - отображает информацию о запущенных контейнерах.</p></li>
            <li class="text"><p><b>docker build</b> - создает изображение из Dockerfile.</p>Пример: docker build -t my_image . (Создает изображение с именем my_image из Dockerfile в текущем каталоге.)</li>
            <li class="text"><p><b>docker pull</b> - загружает изображение или репозиторий из реестра.</p>Пример: docker pull nginx (Загружает образ nginx из регистри Docker Hub.)</li>
            <li class="text"><p><b>docker push</b> - загружает изображение или репозиторий в реестр.</p>Пример: docker push my_username/my_image (Загружает изображение my_image в Docker Hub под username my_username.)</li>
            <li class="text"><p><b>docker images</b> - Отображает информацию о всех локальных изображениях.</p></li>
            <li class="text"><p><b>docker login</b> - Регистрирует пользователя или входит в систему в Docker Hub.</p></li>
            <li class="text"><p><b>docker logout</b> - Выходит из Docker Hub.</p></li>
            <li class="text"><p><b>docker search</b> - Поиск в Docker Hub.</p>Пример: docker search nginx (Поиск образов nginx на Docker Hub.)</li>
            <li class="text"><p><b>docker version</b> - Отображает информацию о версии Docker.</p></li>
            <li class="text"><p><b>docker info</b> - Отображает различную информацию о состоянии Docker.</p></li>
            <li class="text"><p><b>docker build</b> - Используется для создания образа Docker из Dockerfile и .dockerignore файла.</p>Пример: docker build -t my-app . (Создает образ с именем "my-app" на основе Dockerfile в текущем каталоге)</li>
            <li class="text"><p><b>docker-compose</b> - Это отдельная утилита, которая используется для определения и управления многоконтейнерными приложениями Docker. Она позволяет пользователям определять наборы контейнеров в файле YAML, а затем просто запускать эти определения с помощью одной команды.</p>Пример: docker-compose up (Поднимает все контейнеры, определенные в файле docker-compose.yml в текущем каталоге)</li>
            <li class="text"><p><b>docker container</b> - Предназначен для управления контейнерами пользователя.</p>Пример: docker container ls (Отображает список текущих контейнеров)</li>
            <li class="text"><p><b>docker image</b> - Управляет образами Docker.</p>Пример: docker image ls (Отображает список образов)</li>
            <li class="text"><p><b>docker network</b> - Позволяет управлять сетями Docker.</p>Пример: docker network create my-net (Создает новую сеть с именем "my-net")</li>
            <li class="text"><p><b>docker plugin</b> - Позволяет управлять плагинами Docker.</p>Пример: docker plugin ls (Отображает список установленных плагинов)</li>
            <li class="text"><p><b>docker system</b> - Это набор команд для управления информацией о системе Docker, такой как использование дискового пространства и количество запущенных контейнеров.</p>Пример: docker system df (Показывает использование дискового пространства Docker)</li>
            <li class="text"><p><b>docker volume</b> - Управляет томами Docker.</p>Пример: docker volume create my-vol (Создает новый том с именем "my-vol")</li>
            <li class="text"><p><b>docker config</b> - используется для управления конфигурации Docker Swarm.</p></li>
            <li class="text"><p><b>docker service</b> - это команда управляет сервисами в Docker Swarm. Сервисы это как группы контейнеров, которые работают вместе и предоставляют определенный функционал.</p>Пример: docker service create --replicas 5 -p 80:80 nginx запустит сервис с 5 копиями Nginx, доступными на порту 80.</li>
            <li class="text"><p><b>docker create</b> - создает новый контейнер, но не запускает его.</p>Пример: docker create --name my_container nginx создаст контейнер с именем my_container на базе образа nginx.</li>
            <li class="text"><p><b>docker kill</b> - останавливает один или несколько контейнеров.</p>Пример: docker kill my_container остановит контейнер с именем my_container.</li>
            <li class="text"><p><b>docker diff</b> - отображает изменения файлов и директорий в контейнере.</p>Пример: docker diff my_container покажет все изменения в контейнере my_container.</li>
            <li class="text"><p><b>docker load</b> - загружает образ Docker из tar архива.</p>Пример: docker load < my_image.tar.</li>
            <li class="text"><p><b>docker logs</b> - получает логи с контейнера.</p> Пример: docker logs my_container покажет логи контейнера my_container.</li>
            <li class="text"><p><b>docker pause</b> - приостанавливает все процессы в одном или нескольких контейнерах.</p>Пример: docker pause my_container.</li>
            <li class="text"><p><b>docker port</b> - показывает порты сопоставленные наружу по отношению к основным портам контейнера.</p>Пример: docker port my_container покажет это сопоставление для контейнера my_container.</li>
            <li class="text"><p><b>docker rename</b> - переименовывает контейнер.</p>Пример: docker rename my_container new_name переименует my_container в new_name.</li>
            <li class="text"><p><b>docker restart</b> - перезапускает контейнер.</p>Пример: docker restart my_container перезапустит my_container.</li>
            <li class="text"><p><b>docker rm</b> - удаляет один или несколько контейнеров.</p>Пример: docker rm my_container удалит my_container.</li>
            <li class="text"><p><b>docker rmi</b> - удаляет один или несколько образов.</p>Пример: docker rmi nginx удалит образ nginx.</li>
            <li class="text"><p><b>docker save</b> - сохраняет образ в tar архив.</p>Пример: docker save -o my_image.tar nginx сохранит образ nginx в архив my_image.tar.</li>
            <li class="text"><p><b>docker start</b> - запускает один или несколько остановленных контейнеров.</p>Пример: docker start my_container запустит my_container.</li>
            <li class="text"><p><b>docker stop</b> - останавливает действующий контейнер.</p>Пример: docker stop my_container остановит my_container.</li>
            <li class="text"><p><b>docker stats</b> - показывает ресурсы (CPU, память и т.д.), используемые контейнером.</p>Пример: docker stats my_container.</li>
            <li class="text"><p><b>docker tag</b> - присваивает тэг образу, это используется для идентификации версий образов.</p>Пример: docker tag my_image:latest my_image:v1.0.</li>
            <li class="text"><p><b>docker top</b> - показывает процессы внутри контейнера.</p>Пример: docker top my_container.</li>
            <li class="text"><p><b>docker unpause</b> - возобновляет все процессы в контейнере. </p>Пример: docker unpause my_container.</li>
            <li class="text"><p><b>docker update</b> - обновляет конфигурацию контейнера.</p>Пример: docker update --memory "512m" my_container обновит конфигурацию my_container, установив лимит памяти в 512 мегабайт.</li>
            <li class="text"><p><b>docker wait</b> - блокирует выполнение до тех пор, пока контейнер не завершится, а затем печатает exit code.</p>Пример: docker wait my_container.</li>
          </ol>
          <p>Это список из 42 основных команд <b>Docker</b>. Для получения расширенной информации о командах можно прочитать официальную документацию.</p>
        </div>
        <h2>Dockerfile</h2>
        <div class="text">
          <h3>Краткие сведения</h3>
          <p><b>Dockerfile</b> - это текстовый файл, который содержит набор команд для автоматизации процесса создания Docker-образа. Он используется для описания среды выполнения и конфигурации приложения в контейнере Docker. Dockerfile определяет, какие зависимости и настройки нужно установить, как скопировать исходный код приложения в контейнер, и как запустить приложение.</p>
          <h3>Основные команды</h3>
          <p>В <b>Dockerfile</b> могут быть использованы следующие основыне команды:</p>
          <ol>
            <li class="text"><b>FROM</b> - указывает базовый образ, на основе которого будет создан новый образ.</li>
            <li class="text"><b>RUN</b> - выполняет команды внутри контейнера во время сборки образа. Например, установка зависимостей, загрузка пакетов и т.д.</li>
            <li class="text"><b>COPY</b> или <b>ADD</b> - копирует файлы или директории из локальной файловой системы в контейнер.</li>
            <li class="text"><b>WORKDIR</b> - устанавливает рабочую директорию для последующих команд.</li>
            <li class="text"><b>CMD</b> или <b>ENTRYPOINT</b> - указывает команду, которая будет выполнена при запуске контейнера.</li>
            <li class="text"><b>EXPOSE</b> - указывает на какой порт (или порты) контейнер должен открывать соединения.</li>
          </ol>
          <h3>Пример файла</h3>
          <img src="static/Docker/Dockerfile.PNG" alt="Пример Dockerfile">
          <p>В этом примере Dockerfile начинается с базового образа Python версии 3.9. Далее устанавливаются необходимые зависимости контейнера, создается и активируется виртуальное окружение, устанавливаются зависимости Python-проекта из файла requirements.txt. Затем копируется исходный код проекта в контейнер, устанавливается рабочая директория и указывается команда для запуска контейнера, в данном случае - запуска файла "app.py".</p>
        </div>
        <h2>docker-compose.yml</h2>
        <div class="text">
          <h3>Пример файла</h3>
          <img src="static/Docker/docker-compose/example.PNG">
          <h3>Краткие сведения</h3>
          <p><b>Docker Compose</b> — это инструментальное средство, входящее в состав Docker. Оно предназначено для решения задач, связанных с развёртыванием проектов.</p>
          <p><b>Docker Compose</b> используется для одновременного управления несколькими контейнерами, входящими в состав приложения. Этот инструмент предлагает те же возможности, что и Docker, но позволяет работать с более сложными приложениями.</p>
          <p>Представьте себе, что вы являетесь разработчиком некоего веб-проекта. В этот проект входит два веб-сайта. Первый позволяет людям, занимающимся бизнесом, создавать, всего в несколько щелчков мышью, интернет-магазины. Второй нацелен на поддержку клиентов. Эти два сайта взаимодействуют с одной и той же базой данных.</p>
          <p>Ваш проект становится всё популярнее, и оказывается, что мощности сервера, на котором он работает, уже недостаточно. В результате вы решаете перевести весь проект на другую машину.</p>
          <p>К сожалению, нечто вроде <b>Docker Compose</b> вы не использовали. Поэтому вам придётся переносить и перенастраивать сервисы по одному, надеясь на то, что вы, в процессе этой работы, ничего не забудете.</p>
          <p>Если же вы используете <b>Docker Compose</b>, то перенос вашего проекта на новый сервер — это вопрос, который решается выполнением нескольких команд. Для того чтобы завершить перенос проекта на новое место, вам нужно лишь выполнить кое-какие настройки и загрузить на новый сервер резервную копию базы данных.</p>
          <h3>Основные команды</h3>
          <ul>
            <li class="text"><b>up</b> - создание и запуск сервисов</li>
            <li class="text"><b>down</b> - остановка и удаление контейнеров, сетей, образов и томов</li>
            <li class="text"><b>start</b> - запуск сервисов</li>
            <li class="text"><b>stop</b> - остановка сервисов</li>
            <li class="text"><b>restart</b> - перезапуск сервисов</li>
            <li class="text"><b>create</b> - создание сервисов</li>
            <li class="text"><b>rm</b> - удаление остановленных контейнеров</li>
            <li class="text"><b>run</b> - выполнение одноразовой команды</li>
            <li class="text"><b>exec</b> - выполнение команды в зупущенном контейнере</li>
          </ul>
          <h3>Основные поля</h3>
          <ol>
            <li class="text">
              <p><b>build</b> - настройки, применяемые во время сборки.<p>
              <p><b>build</b> может определяться в виде строки - пути к контексту сборки:</p>
              <img src="static/Docker/docker-compose/build_v1.PNG">
              <p>Или в виде объекта, где <b>context</b> - путь к контексту, <b>dockerfile</b> - используемый <b>Dockerfile</b> и <b>args</b> - аргументы:<p>
              <img src="static/Docker/docker-compose/build_v2.PNG">
              <p>В случае с <b>args</b> аргументы должны быть определены в <b>Dockerfile</b></p>
              <img src="static/Docker/Dockerfile/args.PNG">
            </li>
            <li class="text">
              <p><b>network</b> - Сеть, к которой подключается контейнер во время сборки (для использования при выполнении команды RUN):<p>
              <img src="static/Docker/docker-compose/network_v1.PNG">
            </li>
            <li class="text">
              <p><b>command</b> - Перезапись дефолтной команды:<p>
              <img src="static/Docker/docker-compose/command.PNG">
            </li>
            <li class="text">
              <p><b>depends_on</b> - Зависимость между сервисами. Это означает следующее:<p>
              <ul>
                <li class="text"><b>docker compose up</b> запускает сервисы в определенном порядке. В примере ниже <b>db</b> и <b>redis</b> запускаются перед <b>web</b>.</li>
                <li class="text"><b>docker compose up SERVICE</b> автоматически включает зависимости <b>SERVICE</b>. В примере <b>docker compose up web</b> также создает и запускает <b>db</b> и <b>redis</b>.</li>
                <li class="text"><b>docker compose stop</b> останавливает сервисы в определенном порядке. В примере <b>web</b> останавливается перед <b>db</b> и <b>redis</b>.</li>
              </ul>
              <img src="static/Docker/docker-compose/depends_on.PNG">
            </li>
            <li class="text">
              <p><b>restart_policy</b> - Политика перезапуска — определяет, как и когда контейнер должен перезапускаться:<p>
              <ul>
                <li class="text"><b>condition</b>: условие перезапуска — <b>none</b>, <b>on-failure</b> или <b>any</b> (значение по умолчанию);</li>
                <li class="text"><b>delay</b>: время между попытками (по умолчанию равняется 5s);</li>
                <li class="text"><b>max_attempts</b>: количество попыток (по умолчанию — бесконечное);</li>
                <li class="text"><b>window</b>: время принятия решения об успехе перезапуска (по умолчанию — немедленно).</li>
              </ul>
              <img src="static/Docker/docker-compose/restart_policy.PNG">
            </li>
            <li class="text">
              <p><b>entrypoint</b> - Перезапись дефолтной точки входа:</p>
              <img src="static/Docker/docker-compose/enterypoint.PNG">
            </li>
            <li class="text">
              <p><b>env_file</b> - Извлечение переменных среды окружения из файла. Может быть единичным значением или списком.</p>
              <p>Если файл Compose определен с помощью <b>docker compose -f FILE</b>, пути в <b>env_file</b> будут относительными директории, в которой находится этот файл.</p>
              <p>Переменные, определенные в разделе <b>environment</b>, перезаписывают эти значения.</p>
              <img src="static/Docker/docker-compose/env.PNG">
            </li>
             <li class="text">
              <p><b>expose</b> - Выставление портов без их публикации на хосте — порты будут доступны только связанным (linked) сервисам. Могут определяться только внутренние порты:</p>
              <img src="static/Docker/docker-compose/expose.PNG">
            </li>
             <li class="text">
              <p><b>external_links</b> - Подключение к контейнеру, запущенному за пределами <b>docker-compose.yml</b> или даже за пределами <b>Compose</b>. Особенно полезно для контейнеров, предоставляющих общие или распределенные сервисы:</p>
              <img src="static/Docker/docker-compose/external_links.PNG">
              <p><i>Обратите внимание: </i>внешние контейнеры должны быть подключены хотя бы к одной сети, к которой подключен сервис.</p>
            </li>
             <li class="text">
              <p><b>image</b> - Образ для контейнера. Может быть репозиторием/тегом или частичным идентификатором (partial identifier):</p>
              <img src="static/Docker/docker-compose/image.PNG">
              <p>Все образы можно найти на <b>Docker Hub</b></p>
            </li>
             <li class="text">
              <p><b>links</b> - Подключение контейнера к другому сервису. Подключаемый сервис определяется с помощью названия сервиса и синонима ссылки (link alias) (<b>"SERVICE:ALIAS"</b>) или только названия:</p>
              <img src="static/Docker/docker-compose/links.PNG">
            </li>
             <li class="text">
              <p><b>network_mode</b> - Сетевой режим:</p>
              <img src="static/Docker/docker-compose/network_mode.PNG">
            </li>
             <li class="text">
              <p><b>networks</b> - Сети для подключения:</p>
              <img src="static/Docker/docker-compose/networks.PNG">
            </li>
             <li class="text">
              <p><b>ports</b> - Выставление портов.</p>
              <p>Короткий синтаксис позволяет делать следующее:</p>
              <ul>
                <li class="text">определять оба порта (<b>HOST:CONTAINER</b>);</li>
                <li class="text">определять только порт контейнера (для хоста выбирается эфемерный порт);</li>
                <li class="text">определять <b>IP-адрес</b> хоста для привязки (bind) и оба порта (значением по умолчанию является <b>0.0.0.0</b>, что означает все интерфейсы) (<b>IPADDR:HOSTPORT:CONTAINERPORT</b>).</li>
              </ul>
              <img src="static/Docker/docker-compose/ports_short.PNG">
              <p>Длинный синтаксис позволяет настраивать дополнительные поля:</p>
              <ul>
                <li class="text">
                  <b>target</b>: порт контейнера;
                </li>
                <li class="text">
                  <b>published</b>: порт хоста (доступный публично);
                </li>
                <li class="text">
                  <b>protocol</b>: протокол порта (<b>tcp</b> или <b>udp</b>);
                </li>
                <li class="text">
                  <b>mode</b>: <b>host</b> | <b>ingress</b>.
                </li>
              </ul>
            </li>
             <li class="text">
              <p><b>restart</b> - Определение политики перезапуска.</p>
              <p>Значением по умолчанию является <b>no</b>, что означает отключение автоматического перезапуска.<br> <b>always</b> означает перезапуск в любом случае.<br><b>on-failure</b> означает перезапуск только в случае аварийной остановки контейнера.<br> <b>unless-stopped</b> означает перезапуск контейнера во всех случаев, кроме преднамеренной остановки:</p>
              <img src="static/Docker/docker-compose/restart.PNG">
            </li>
             <li class="text">
              <p><b>entrypoint</b> - Перезапись дефолтной точки входа:</p>
              <img src="static/Docker/docker-compose/enterypoint.PNG">
            </li>
          </ol>
          <h3>Основные технологии для развертывания</h3>
        </div>
      </div>
    </div>
  </body>
</html>